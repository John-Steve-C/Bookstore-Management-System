## 第一次：2021.12.5

完成开发文档的编写。

实际上是三人，每人完成一个类的接口。

而且命名规则也不尽相同，助教审核后，指出我有不少的错误。

比如对块状链表的理解完全不对（我当初是照搬给定的模板，而在接下来这周的尝试中就暴露了这个问题）。

---

## 第二次：2021.12.12

本来想按照助教给的块状链表模板来实现，然而始终无法完成。感觉就是思想能够理解，然而一旦和文件关联起来，我就懵逼了，根本无从下手。这种情况持续了2，3天。

于是只好参考qwerry的代码。

- 原本的模板是把find,add,delete,merge等等操作，放在**blocklist**里面操作。而他的则是放在**block**里面操作。这样确实比较清楚，但是对应的findNode操作就会更加复杂。

- 需要建立一个映射关系，让blocklist能够访问到每一个block。助教的模板用的是nxt，pre两个“指针”，而他的代码是新建了blockindex类。

- 所以，他还新建了一个blockindex类，是blocklist的友元，~~用来**临时**记录每个block的信息，而 成员offset[]和back[] 就充当了这一映射。~~ 现在明白了，就是用来访问和查询的索引类。

- 一些知识点：

  > lower_bound：二分查找，直接保证有序性
  >
  > memcpy：数组的复制
  >
  > 用指针+数组名，将数组作为函数的参数进行传递（也可以引用传递vector）

---

## 12.12 18：00 

今天就真的是**自我设限**的生动示范。我以为Lynn写的是B+Tree，不会块状链表，但是事实上，他十分热情，主动来帮我解答了我的疑惑。

听Lynn大神一番讲解，我才发现自己对块状链表的理解仍然是不够透彻（或者说是不懂装懂），实际上是一个block分为2部分：array（存数据）和 head_Index（存key和用int表示的地址）。   [建议参考OI Wiki](https://oi-wiki.org/ds/block-list/)

- 同时要保持元素的有序性，就要每次都通过key来比较查找。
- 记得保存每个块的“地址”，其实就是序号

- 与文件读写相结合，就是把文件“分块”，按照位置来分，在外存中进行操作。
- 然而，我似乎还是不会做？
- 键值数据库的思想，是利用2个文件：索引文件和数据文件。先找到要查询的数据对应的索引，再通过索引去访问数据文件。所以，也可以把索引和数据分开存储，当成2个文件？
- 

