## 第一次：2021.12.5

完成开发文档的编写。

实际上是三人，每人完成一个类的接口。

而且命名规则也不尽相同，助教审核后，指出我有不少的错误。

比如对块状链表的理解完全不对（我当初是照搬给定的模板，而在接下来这周的尝试中就暴露了这个问题）。

---

## 第二次：2021.12.12

本来想按照助教给的块状链表模板来实现，然而始终无法完成。感觉就是思想能够理解，然而一旦和文件关联起来，我就懵逼了，根本无从下手。这种情况持续了2，3天。

于是只好参考qwerry的代码。

- 原本的模板是把find,add,delete,merge等等操作，放在**blocklist**里面操作。而他的则是放在**block**里面操作。这样确实比较清楚，但是对应的findNode操作就会更加复杂。

- 需要建立一个映射关系，让blocklist能够访问到每一个block。助教的模板用的是nxt，pre两个“指针”，而他的代码是新建了blockindex类。

- 所以，他还新建了一个blockindex类，是blocklist的友元，~~用来**临时**记录每个block的信息，而 成员offset[]和back[] 就充当了这一映射。~~ 现在明白了，就是用来访问和查询的索引类。

- 一些知识点：

  > lower_bound：二分查找，直接保证有序性
  >
  > memcpy：数组的复制
  >
  > 用指针+数组名，将数组作为函数的参数进行传递（也可以引用传递vector）

---

12.12 18：00 

今天就真的是**自我设限**的生动示范。我以为Lynn写的是B+Tree，不会块状链表，但是事实上，他十分热情，主动来帮我解答了我的疑惑。

听Lynn大神一番讲解，我才发现自己对块状链表的理解仍然是不够透彻（或者说是不懂装懂），实际上是一个block分为2部分：array（存数据）和 head_Index（存key和用int表示的地址）。   [建议参考OI Wiki](https://oi-wiki.org/ds/block-list/)

- 同时要保持元素的有序性，就要每次都通过key来比较查找。
- 记得保存每个块的“地址”，其实就是序号
- 与文件读写相结合，就是把文件“分块”，按照位置来分，在外存中进行操作。
- 然而，我似乎还是不会做？
- 键值数据库的思想，是利用2个文件：索引文件和数据文件。先找到要查询的数据对应的索引，再通过索引去访问数据文件。所以，也可以把索引和数据分开存储，当成2个文件？
- 实际上，就是先在存储的文件中，寻找到要操作的块的位置。然后把整个块读入到内存里进行处理，最后再重新写入到文件里。

---

## 12.15 	21:17

- 按照fqj的写法，写完WA了一大片，甚至还segmentation fault.
- 好累。要不要借鉴一下zbl的思路。fqj的做法是在外层的linklist中记录每个块的位置和头节点，用来比较。
- 而zbl的想法是传统型的。就是在block中维护pre,next,pos，真的像链表一样来顺序访问。缺点是访问会稍微偏慢，但是容易理解。
- 所以，我选择重构，想zbl的做法靠拢。
- 说是重构，其实就是半抄半做。基本都是在**“借鉴”**。fw
- 有一点需要注意，就是数据是要 **随时从文件中读取，处理结束后就立刻重新写入文件** 的。
- 所以不仅是数据，还有块数（第一个）、delete_start（第二个）都要在更新后，写回文件。
- key查找的时候，可能会跨过块出现。

---

12.16 15：00

- 这几次，已经很清楚的说明了，越复杂的工程，越不能抄代码。只有自己理解了，并自己去实现，才能真正掌握。不然，对着抄了一遍，还是似懂非懂，一旦有错误的地方，就根本没办法调试。

---

12. 18 10：08

经历了一个礼拜的颓废，终于把前置的简单题过了。

最后对着zbl的模板来修改，也算是完全理解了块状链表的思想和操作。但是却一直WA。

因为我的MemoryRiver类写挂了。而这个类我当初也是借鉴别人的，有好多细节也是似懂非懂。比如所谓的 sizeofNode 到底有什么用，我只是简单的理解为复合节点，却不考虑背后的原因。

害死人！

不仅是理解透彻，自主实现，还有一点，就是调试的能力要加强，心态要稳住。

为什么比周老师先开始写，还比他晚完成呢？就是没有真正理解知识点，而且心态浮躁。

写一下周老师的思路：

- del_head 相当于 delete_start，存储的是，上一次删除数据后，释放的空间的位置（指针）。若为0，说明没有被释放的空间，直接在文件的尾部插入即可。

- 在文件的开头预留了 2 个 int 的位置，分别用来存储 num_T （块数）和 del_head。后面再开始存块的信息。

  因为sizeof(int)=4，所以块的起始位置 fpos 就是 2 * 4 = 8。所以计算位置的时候，都要写成2 * sizeof(int) + num_T * sizeofT

- 因为Bookstore系统是基于文件实现的，所以在更新数据的同时，记得要先把数据从文件中取出，再重新写回文件里。（**write_info/write/update**）

- 在merge，split，第一次add_node等操作中，块数（num_T）会改变，但是我没有在MemoryRiver类中进行修改，而是在**外面**，先进行如下操作： 
	```cpp
	get_info(num, 1);
	num++;
	write_info(num, 2);
	```
   再进行write，才能保证正确性。
  
  当然，也可以把num_T++的操作放到MemoryRiver类中实现。
  

---

## 第三次：2021.12.22

今天在宿舍学习。大体上还是能学进去，就是吃完饭玩了将近2个小时的电子产品。

不得不说，刘祎禹的 **开发文档** 写的真的很好，接口的设计和存取都十分巧妙，解决了好多我当初不理解的问题。

期末复习！！还没开始啊！

目前已经完成了command类。

account写了一半，尚未进行权限的判断。

- 刚才一直提示unknown type,因为我把两个库相互引用了QWQ。也要注意，类的定义和实现中，不能出现重复的include

  循环引用的解决方法：把其中一个include 改成class 就可以了。

  [真正的解决方法。](https://blog.csdn.net/libing_zeng/article/details/80875052)

- 要修改类之间的访问权限？不要直接把private成员改成public，多用**友元**

- 不要忘记默认构造函数

---

## To do :

- [x] file_io，ull

- [x] command类

- [x] 权限判断

- [x] 通过id_to_pos来充当索引文件

- [ ] log类，除了show finance以外的其他指令(bonus)

- [x] account/bookdatabase的LogManagement，把其他类中的操作与日志联系起来

- [x] 记得使用stod(stoi)函数，直接把string转化为double/int

- [x] 修改操作，

  > 先 book_data.read(new_book, pos);
  >
  > 再修改new_book
  >
  > 最后book_data.update(new_book, pos);

- [x] 异常类Exception，比直接printf(Invalid)更优秀

- [x] bookManegement类中，show的多关键字匹配

  show要么没有参数，要么只会有一个参数。

- [x] bookManagement类，会有多个keyword，

  keyword的存储和匹配方式要修改，二维数组？vector？

  不用，直接把整个字符串存进去，匹配的时候再取出来一一判断即可。每个keyword都要单独放到ull中

  记得把Command的分隔符设置为 |

- [ ] 可以优化上述的操作，在每一个book中，新开一个string[61] 用来存储所有的keyword，不修改的时候，可以用来比对

- [ ] 修改了一下Cmakelist，结果发现运行不了了？code文件不存在？

- [x] Import指令的quantity

---

先开始测试account部分的正确性。

- [x] 没有对刚开始，登录栈为空的情况进行特判。

  并不是，我有写构造函数，先加入root账户。

  ---

  实际上，我弄乱了。

  一个user有昵称(name，可有可无，如root就没有)和真实姓名(ID，必须要有，root就是ID)

  ---

  现在的问题是，MemoryRiver的get_info函数失效了。

  id_to_pos等ull中的MemoryRiver，他的filename为空？

  破案了，单独开的user_data(MemoryRiver)有初始化，而id_to_pos（ull）没有。。。

  所以只要把AccountManagement等等的 **构造函数** 写好就行了。不需要参数，直接固定存放的文件名称？

- [x] next_token写错了

- [x] Memory_River封装不合理。当初的写法是把存储块数的num定义在ull中，每次要调用的时候再读取。

  这么写会导致num只有依附于ull的调用才有意义，而单独声明一个Memory_River类，使用num则会出现问题。（就是刚开始的那一题，都过不了）。

  ---

  #### 以下为调试MemoryRiver.hpp中的错误

  ~~先打开文件才能get_info啊...~~ file.open()操作已经包含在get_info、write_info中了，否则会Disk Limit Exceed。

  所以get_inf和write_info前，file应该是close的。

  num_T和del_head在开头从文件读入，在结束时写入文件

  小作业的那题，不需要判断文件是否打开成功，即文件是否存在。害得我多调试了半个小时。

- [x] 更新name_to_pos数据的时候，如何找到新的pos？

  ~~对不起，今日nt~~。pos表示的是在MemoryRiver类中的位置，是不会变的。

  ---

## 2021.12.27

- [x] strcmp出问题了？不能忽略末尾的/r ?

  其实是command的问题，把换行符'/r'也读入到了string当中

- [x] user_add会出现缺省参数的问题？

  **大于等于** 当前权限的账户都不能被添加！审题！！

- [ ] register后是否会登录账户？

- [x] change_passwd忘了判断权限问题

- [ ] user_name是可以有空格的。应该说，可见的ASCII字符都可以。。。所以应该修改分隔符？`line.set_delimiter()`就可以

  不能这么看，应该直接进行参数数目的比较

- [x] 同时，题面中没有`?`的参数，就不能出现参数的缺省。所以读入完，还要进行判断！！！严格按照题意来实现！

  参数必须 **严格匹配**，不能多也不能少。

- [x] next_token的读入方法是实时处理的，用来比较参数个数确实不方便。

  所以可以在构造函数中写一个count。

- [x] modify操作，即使创建新书，也要选定它。

- [x] ISBN和price的读入是没有引号的。

- [x] show少输出，问题在于ull的add_node没有实时更新num...（即从文件中get_info）

  凡是涉及到num的操作，都要先get_info...

- [ ] 每测试一个case，都能发现好多细节的错误...

- [x] 不能有两本ISBN相同的书。

- [x] 输出的顺序是ISBN升序。

  比如说，我写的是`author_to_pos`，是以author(string)为关键字的，并不是isbn?

  所以，找出这些书后，~~还要再到`ISBN_to_pos`中查找~~，保证顺序正确，再加入ans数组中。（只要关键字不是author的show，都要这么做）

  直接维护一个以ISBN为关键字的 **优先队列**。同时要重载 Book 的 `<` 号（以ISBN为关键字）

- [x] 读入相关信息的时候会出现乱码？是不是越界的问题？

  应该是没有赋初值。比如说没有modify一本书的作者，那么输出author的时候就应该输出""(也就是空)

  =default是赋空吗？

- [x] complex test 出问题，因为没有判断show finance的非法情况，权限为7。

  暂时放在main函数中实现

  ---

## 鲁棒性测试（真烦）

- [x] 鲁棒性测试出现问题。

  import指令中，在quantity的位置输入了字母，要判断是否为数字。

  也就是在所有涉及字符转数字的地方，都要进行判断。

  事实上，当stoi()出现不合规范的转化时，它会抛出异常。

  所以只要在main函数中做catch操作即可

- [x] 退出系统视为 **取消** 选中图书。

  似乎没有判断

  有的，登录栈的实现就可以了。

- [x] ~~modify的参数内容和原来的 **完全一致**（也就是没改变），是非法的~~

  并不是，以上在胡思乱想。所以没改变的modify是合法的？

  实际上，错误的原因是，modify中出现了重复的关键词。

  比如 `-keyword=1|1` 就是非法的。

  用一个类似桶的结构来实现（set）

  而且这个判断应该在 **所有**的**赋值操作之前**完成。也就是说，不能边读边赋值，更新数据要在合法性确定后，最后执行。

- [ ] 只剩最后一个点WA了，但是给的数据好像不是按顺序的。QWQ

- [ ] 到晚上，做了一点特判，然后发现 1.in 错了，多输出了2个Invalid。

  问题就出在，~~低权限是可以登录高权限的，只要密码正确即可。~~ token的读取，没有忽略行末空格。比如说

  `su root sjtu \r`,读出来的 `cnt` 是4，实际上是3

  在command的count函数中，分段的读取，两段的条件不同

- [x] 而且，我昨天晚上熬夜到2点，应该是已经神志不清了，明明错的是第一个点，我却看成第三个QWQ

- [x] 破案了，libro助教真的给力。我没有判断读入空行...

  要修改读入的方式，直到读到EOF才停止
  
  修改后，Innertset第一组AC

---
Inner test一个都过不了。开始重新阅读题目

- [x] 合法的字符集，是标准ACSII（0-127）？

  出锅了。首先，为什么在command中进行前置类型的声明，include<Exception.h> 就会报错

  还有就是`const char* `不能和`int` 比较吗？

  决定，直接放在main函数中判断

- [x] 不同参数的合法字符集是不同的。

  比如``userID,password``只能是数字、字母、下划线。长度上限为30（在读入的时候判断即可）

- [x] 每行命令的长度不超过1024

- [x] 林田川提供的思路，keyword中的分隔符 `|` 不能有多个连续出现的情况

- [x] 重大错误，代码异常情况的判断顺序，要严格按照给定的 `README` 的顺序来实现。

  也就是说，如果是root登录低权限的用户，并输入了密码，~~那么无论正误都是合法的~~，就必须判断密码的正误，如果错就`Invalid`。

  已经对account和bookdatabase进行了输入合法性判断。

  Innertset第二组AC。

- [x] keyword中，不能以`|`开头结尾

- [x] show , modify 中的 -name= 要判断是否严格匹配

- [x] 第三组全是show，所以捏了一下数据，发现我没有判断show的cnt，遇到

  > show -keyword="asdasdasdasdasd" sdfsdfsdf

  应该输出`Invalid`，但我不是！

  同样的，如果选定一本书，

  > select 1
  > modify -ISBN=2 455

  后面有多余的参数455，应该报错

  改完后，第三组多对了3个点，还剩2个。

- [x] 发现show传入的参数合法性有判断，而modify没有！

  改完，第三组的倒数第二个过了。但是我好像也有在下面搞判断？不是很懂。

- [x] log 命令的合法性判断！

  它说明了，不会在输入中出现`log`和`report`，所以一旦读到，就直接`Invalid`。

  改完通过了最后一组的最后一个点。

- [x] ‘\t’有判断

- [ ] price和quantity可能是负数？（不是这个问题）

- [x] show finance的limit可能不是整数

  改完AC了！

  可以同步开始写Bonus...

- [ ] report指令

- [x] report finance 相当于 showfinance?

---

## 2022.1.15

期末考完，放假回家了。

前几天，完成了cr。根本没有写bonus。

所谓的“美观的日志”，我并没有实现。事实上，直接记录每一条命令的信息，到时候按照特定的输出就可以了。

仇天元学长向我说明了，事实上，当我们真正去工作的时候，遇到的要求，大多都是去实现bonus里面的各种功能，而主体部分的实现反而更少。

当我真正去理解的时候，主体部分的实现，这次确实没什么难度。主要是debug花费了太多时间。

而bonus也没有像想象中的那么难，像CLI（数字选择界面，可以用函数指针实现）、备份文件、支持中文和emoji...

比较困难的是，GUI前端的实现、Bp tree

总的来说，这次的大作业，完成的还是不错的。

在寒假里面，可以尝试着去写一点bonus，然后去把 `Python Intepreter` 补全一下。
